<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-15">
  <meta name="generator" content="PSPad editor, www.pspad.com">
  <title>readme</title>
</head>
<body>
<h1>Projet Mowers</h1>
<em>Application serveur REST avec Spring MVC & MongoDB</em><br/><br/>
Jean-Baptiste HUNTZINGER, 2013<br>
<br>
<h2>Présentation du projet Mowers (= tondeuses en francais)</h2>
Cette application est inspirée du test d'entretien technique d'une société de conseil, dans le cadre d'un recrutement pour un poste<
d'architecte J2EE.<br>
Pour la petite histoire j'ai réalisé le test très (trop) rapidement, et je n'ai pas pu continuer le processus d'entretien...<br>
Mais le correcteur m'ayant fait des remarques précises sur ce qui n'allait pas, j'ai décidé de réécrire ce test en élargissant
les spécifications d'origine et en profitant de l'occasion pour utiliser des outils open source actuels: Spring Source (le framework
que j'avais déjà utilisé, mais en 2005 !), MongoDB (Base de donnée NoSQL orientée documents éditée par une société américaine: 10gen)
et angular.js coté client (Google, framework javacript).<br>
L'objectif pragmatique étant  de préparer mes entretiens suivants avec une référence récente sur ces technologies.<br>
<br>
<br>
<h2>Les spécifications</h2>
Il s'agit de simuler le déplacement d'unités mobile (des tondeuses, dans un premier temps) sur une surface (un jardin rectangulaire, <br>
toujours dans un premier temps).<br>
<br>
Pour expliquer simplement le but du projet, on part du cas le plus simple qui est traité par l'application: une surface rectangulaire que l'on appelle le jardin,<br>
 et des tondeuses pour les unités mobiles. <br>
La taille du jardin est définie par sa longeur et sa largeur, et chaque emplacement du jardin est représentée par une 'case' sous forme de coordonnée (x, y).<br>
Chaque tondeuse est initialement placée sur une case (x1, y1), et orientée suivant une direction correspondant à un point cardinal: 'N'ord, 'S'ud, 'E'st, 'O'uest.<br>
Par exemple une tondeuse sur la case (0,0) et orientée 'N' se trouve en bas à gauche du jardin, et tournée vers le nord.<br>
<br>
Elle peut être déplacée selon des ordres, qui sont transmis sous forme de séries de mouvements unitaires:<br>
<ul>
  <li>'D' pour pivoter la tondeuse à droite<br></li>
  <li>'G' pour pivoter la tondeuse à gauche<br></li> 
  <li>'A' pour avancer sur la case en face de la tondeuse<br></li>
</ul>
Pour une situation ou les unités sont forcemment des tondeuses, et la surface un jardin, l'application peut prendre en entrée un fichier ou un flux de texte,<br>
qu'il interprète afin de créer un jardin, une ou plusieurs tondeuses, puis pour chaque tondeuse de la placer dans le jardin et lui appliquer une série de mouvements<br>
unitaires.<br>
La structure du fichier est la suivante:<br>
<ul>
  <li>Première ligne: largeur et longueur du jardin<br></li>
  <li>Puis 2 lignes pour chaque tondeuse (numérotées de 1 à n):<br>
    <ol>
	   <li>Définition de la tondeuse n: position initiale de la tondeuse: x,y et orientation 'N', 'S', 'E' ou 'O'<br></li>
	   <li>Séquence d'ordres de déplacement associée à la tondeuse n sous forme d'une série de lettres: 'D', 'G' ou 'A'<br></li>
	 </ol>
	</li>
</ul>
<br>

Exemple:<br>
<code>
10 10<br>
0 0 N<br>
AADAA<br>
5 5 S<br>
AGAGAD<br>
</code>
<br>
La première ligne indique la création d'un jardin de taille 10x10<br>
Les 2 lignes suivantes indiquent la création et le positionnement d'une tondeuse sur la case (0,0) du jardin, tournée vers le nord.<br>
La séquence correspond, sous forme de phrase: "Avance de 2 cases, pivote à droite, avance de 2 cases"<br>
Idem pour les 2 dernières lignes qui définissent une tondeuse sur la case (5,5) du jardin, tournée vers le sud, et dont la<br>
séquence correspond à "Avance d'une case, pivote à gauche, Avance d'une case, pivote à gauche, Avance d'une case, pivote à droite"<br>
<br>
Après traitement de ce fichier par l'application, et exécution des ordres de déplacement,  les positions des tondeuses sont:<br>
Tondeuse 1: coordonnées=(2,2) orientation='E'<br>
Tondeuse 2: coordonnées=(6,5) orientation='E'<br>
<br>
<h2>Les objets métiers / domaine</h2>
Le domaine est composé de 3 types d'entités (en italique, les classes abstraites):
<ul>
  <li><strong><i>Surface</i></strong>, <strong><i>SurfaceRectangulaire</i></strong>, <strong>Jardin</strong>: représentation de la surface sur laquelle évoluent les unités<br></li>
  <li><strong><i>Unit</i></strong>, <strong>Mower</strong>: les unités mobile, dont les tondeuses<br></li>
  <li><strong>RoundOrders</strong>: entité regroupant une surfaces, les unités qui s'y trouvent et une série de mouvements unitaires sur chacune des unités<br></li>
</ul>
<br>

<h2>Installation et lancement de l'application</h2>
L'application Mowers est réalisé sous Maven2, elle peut donc être installée de manière simple par exemple et saisissant la ligne de commandes:<br>
  <code>
	mvn install <br>
	</code>
dans le répertoire du projet.<br>
<br>
Mowers utilise Spring MVC, avec des controlleurs pour les Surfaces, les Unités, les RoundOrders.<br>
Le déployment sous un serveur Tomcat local peut se faire avec la commande:<br>
  <code>
	mvn tomcat:deploy (ou mvn tomcat:redeploy)<br>
	</code>
<br>
Des tests unitaires sont écrits, que l'on peut lancer à l'aide d'eclipse ('Run configuration' de type JUnit) ou de maven (mvn test).<br>
La lancement de l'application sous eclipse ou en ligne de commande prend en argument un nom de fichier qui doit se situer dans le dossier<br>
mowers/src/main/config. Ce fichier contient les instructions d'entrées telles que définies ci-dessus.<br>
Par défault il s'agit du fichier input.txt<br>
 <br>
<br>
Coté MCV, des méthodes REST sont disponibles pour les Surfaces et les Unités<br>
Pour tester le controller Surface controller, à partir du plugin firefox Mozilla Rest Client, par exemple:<br>
<br/>
<table name="rest_commands_table" cellpadding="0" cellspacing="0" border="1">
  <thead>
  <tr>
    <th>Interface REST</th> 
    <th>URL</th>
    <th>Requête:header</th>
    <th width="200px">Requête:body</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan="4" align="center">Interface REST sur les surfaces</td>
    </tr>
    <tr>
      <td>GET<br/>Liste</td>
      <td>http://localhost:8080/mowers/rest/surface</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>POST<br/>création</td>
      <td>http://localhost:8080/mowers/rest/surface</td>
      <td>{"type":"jardin","name":"Mon petit jardin","mWidth":5,"mHeight":6}</td>
      <td>"Content-Type: application/json", "charset: utf-8"</td>
    </tr>
    <tr>
      <td>PUT<br/>modification</td>
      <td>http://localhost:8080/mowers/rest/surface/[objectID]</td>
      <td>{"type":"jardin","name":"Mon plus si petit Jardin","mWidth":7,"mHeight":6}</td>
      <td>"Content-Type: application/json", "charset: utf-8"</td>
    </tr>
    <tr>
      <td>DELETE<br/>suppression</td>
      <td>http://localhost:8080/mowers/rest/surface/[objectID]</td>
      <td>&nbsp;</td>
      <td>"charset: utf-8"</td>
    </tr>
    <tr>
      <td colspan="4" align="center">Interface REST sur les unités</td>
    </tr>
    <tr>
      <td>GET<br/>Liste</td>
      <td>http://localhost:8080/mowers/rest/unit</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>POST<br/>création</td>
      <td>http://localhost:8080/mowers/rest/unit</td>
      <td>{"type":"mower","name":"Ma tondeuse"}</td>
      <td>"Content-Type: application/json", "charset: utf-8"</td>
    </tr>
    <tr>
      <td>PUT<br/>modification</td>
      <td>http://localhost:8080/mowers/rest/unit/[objectID]</td>
      <td>{"type":"mower","name":"Ma tondeuse nouveau nom"}</td>
      <td>"Content-Type: application/json", "charset: utf-8"</td>
    </tr>
    <tr>
      <td>DELETE<br/>suppression</td>
      <td>http://localhost:8080/mowers/rest/unit/[objectID]</td>
      <td>&nbsp;</td>
      <td>"charset: utf-8"</td>
    </tr>
  </tbody>
</table>
<br>
<br>
<br>
<h2>Considérations techniques - difficultés rencontrées</h2>
<h3>Tests unitaires des fonctions CRUD sur les entités Surface, Unit et RoundOrders</h3>
Ces tests sont regroupés dans la classe MowersDbTest. Afin de pouvoir les lancer sans avoir installé (ou lancé) le serveur MongoDb,<br>
j'ai tenté d'utiliser le package de.flapdoodle.embedmongo, qui permet de charger et lancer une instance de mongodb directement en runtime.<br>
Toutefois, lors du lancement sur une nouvelle machine, le temps de chargement de MongoDb peut être long.<br>
De plus sur Windows, des alerte de sécurité sont lancée pour permettre au serveur mongodb d'écouter sur le port configuré.<br>
Enfin la solution ne semble pas toujours très stable...<br>
Du coup, le fonctionnement actuel consiste à vérifier que MongoDB est installé avant exécuter les tests, et de <br>
désactiver ces dernier en utilisant org.junit.Assume.assumeTrue dans le Setup du test. <br>
<br>
<h3>Mapping / conversion entre les objets du modèle et les DBObjet MongoDB</h3>
J'ai rencontré des difficultés, des exceptions étant provoquées dans module de conversion de Spring Data (package org.springframework.data.mapping),<br>
lorque je faisais un findById sur mon modèle Surface:<br>
<code>
	MongoOperations mongoOperation = getMongoOperations();<br>
	Surface savedSurface = mongoOperation.findById(objectId, Surface.class, "surfaces");<br>
</code>
il s'est avéré que c'était probablement dû au nom de certaines propriétés dans ma class Surface:<br>
<code>
  protected int max_position_X;<br>
</code>
le mapper de Spring Data interprétant le 'max' comme un mot clé... le nommage des propriétés en camel-case à réglé le problème: maxPositionX.<br>
<br>
<h3>Mapping / conversion entre les éléments en JSON transmis aux controlleurs et les objets du domaine(sérialisation / désérialisation)</h3>
La librairie utilisée pour parser le JSON et instancier les objets du domaines, dans un sens, et au contraire sérialiser les objets du domaine sous forme de flux JSon dans l'autre direction est Jackson.<br>
A priori pour que la désérialisation fonctionne, il faut définier un constructeur vide sur les objets de domaine (ce n'est pas idéal en terme d'architecture...).<br>
Gestion du polymorphisme: afin de ne garder qu'un seul point d'entrée dans les controlleurs pour la création / modification d'objets métiers en utilisant la classe abstraite (Unit et Surface), <br>
il faut préserver l'information sur la classe réelle d'une entité dans le flux JSON. Ceci est réalisé à l'aide d'annotations spécifiques à la librairie Jackson, associées à la classe abstraite:<br>
<code>
@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property="type")<br>
@JsonSubTypes({<br>
      @JsonSubTypes.Type(value=Mower.class, name="mower")<br>
  }) <br>
public abstract class Unit  {<br>
...<br>}
</code>
<br>
Le principe retenu ici consiste à ajouter une propriété dans la classe Unit, type, qui va spécifier le type de l'objet. <br>
Les annotations ci-dessus permettent au parser Jackson d'utiliser la valeur de cette propriété pour connaitre la classe qui est associée à l'entité.<br>
Les constructeurs des classes héritées de Unit vont fournir la valeur adéquate (type="mower" pour la classe Mower).<br>
 <br>
<br>
<h3>Supression d'un élément dans mongoDB</h3>
en réalisant mes tests unitaires, j'ai constaté que la méthode remove de mongoDB ne fonctionnait pas:<br>
  mongoOperation.remove(surface, "surfaces");<br>
Après avoir tout essayé, j'ai fini par découvrir qu'il s'agit bien d'un bug présent sur plusieurs releases de la librairie spring-data-mongodb (https://jira.springsource.org/browse/DATAMONGO-346).<br>
16/03/2013: n'ayant pas pu trouver une combinaison de releases ou le problème sur la méthode MongoTemplate.remove était corrigé, j'ai fini par trouver une alternative efficace en utilisant la méthode MongoTemplate.findAndRemove<br>
<br>
<h3>Déployement avec le plugin tomcat-maven-plugin</h3>
Difficultés: url de deployement modifiée sur Tomcam 7 (http://localhost:8080/manager/text au lieu de http://localhost:8080/manager)<br>
Credential doivent être dans .m2/settings.xml (ceux dans le fichier config/settings.xml du répertoire d'installation de Maven ne semble pas pris en compte)<br>
Dans tomcat-users.xml, les droits sont: &lt;user username="admin" password="admin" roles="manager-script,manager-gui"/&gt;<br>
Attention a garder le meme nom de serveur entre settings.xml et le pom.xml <br>
<br>
<br>
<h3>Test des méthodes REST avec l'extension Mozilla REST client: fonctionnement de la méthode POST</h3>
POST avec un enregistrement au format JSon: "415 Type de Support Non Supporté", "405 - Request method 'POST' not supported": il ne faut pas oublier de préciser les headers suivants:<br>
<code>
  Content-Type: application/json<br>
  charset: utf-8<br>
</code>
No suitable constructor found for type [simple type, class ] (dans les logs): apparemment il est nécessaire de définir un constructeur par défaut, sans paramètres.<br>
<br>
<br>
<h2>Roadmap du projet</h2>
Travailler sur le projet 'client', avec angular.js. A priori ce sera un projet eclipse distinct, qui utilisera JSON pour communiquer avec l'application backend Spring MVC (interfaces spécifiées dans le tableau précédant).<br>
<br>
<br>
<h2>Références</h2>
<ul>
  <li><a href="http://www.springsource.org/spring-data/mongodb">Spring Data - MongoDB (Documentation Springsource.org)</a></li>
  <li><a href="http://getj2ee.over-blog.com/article-tutorial-rest-with-spring-mvc-and-maven-97283997.html">Tutorial : REST with Spring MVC and Maven (16 mars 2012, David Gimelle)</a></li>
  <li><a href="http://blog.springsource.com/2009/03/08/rest-in-spring-3-mvc">REST in Spring 3: @MVC (Arjen Poutsma, 08/03/2009)</a></li>
</ul>
</body>
</html>
